{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm/concept/what-is-union-find/","result":{"data":{"site":{"siteMetadata":{"title":"JIKOID","description":"천천히 그리고 꾸준히"}},"markdownRemark":{"id":"a2ec3088-6d51-5969-b1fc-69464a0626e0","excerpt":"Union-Find 알고리즘이란  에 대한 개념에 대해서 이해하기 전에  자료구조에 대해서 먼저 이해해야 한다. Disjoint set…","html":"<h2 id=\"union-find-알고리즘이란\">Union-Find 알고리즘이란</h2>\n<p><code class=\"language-text\">Union-Find</code> 에 대한 개념에 대해서 이해하기 전에 <code class=\"language-text\">Disjoint Set</code> 자료구조에 대해서 먼저 이해해야 한다.</p>\n<h3 id=\"disjoint-set-이란\">Disjoint set 이란</h3>\n<p><code class=\"language-text\">Disjoint set</code> 이란 <strong><U>서로 중복되지 않는 부분 집합</U></strong> 들로 나누어진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.<br>\n다시 말해 공통 원소를 가지고 있지 않는, <code class=\"language-text\">상호 배타적</code> 인 부분 집합들로 나누어진 원소들에 대한 자료구조이다. <code class=\"language-text\">서로소 집합</code> 이라고도 부른다.</p>\n<p>Disjoint set 자료구조를 사용하면 서로 다른 원소들이 같은 집합에 속해있는지 혹은 속해있지 않은지 판별하는데 유용하다고 한다.</p>\n<p>Disjoint set 는 다음과 같이 3가지 연산을 지원해야 한다.</p>\n<ul>\n<li><code class=\"language-text\">Make-set(초기화)</code> : N 개의 원소가 각각 집합에 속하도록 초기화해야 한다.</li>\n<li><code class=\"language-text\">Union(합치기)</code> 연산 : 두 원소가 주어졌을 때 두 원소가 속한 집합을 하나로 합친다.</li>\n<li><code class=\"language-text\">Find(찾기)</code> 연산 : 어떤 원소가 주어졌을 때 해당 원소가 속한 집합을 반환한다.</li>\n</ul>\n<p>Union 연산과 Find 연산이 필요해 <code class=\"language-text\">Union-Find 알고리즘</code> 이라고 부르게 되었다고 한다.</p>\n<p>따라서 <code class=\"language-text\">Union-Find</code> 알고리즘이란 Disjoint set 자료구조를 표현할 때 사용하는 알고리즘이라는 것을 알 수 있다.</p>\n<p>알고리즘에서 사용할 집합을 구현하기 위해서는 벡터, 배열, 연결 리스트 등의 자료구조를 사용할 수 있지만 <code class=\"language-text\">트리 구조</code> 를 사용해야 효율적으로 구현할 수 있다.</p>\n<br>\n<h2 id=\"union-find-알고리즘-이해하기\">Union-Find 알고리즘 이해하기</h2>\n<p>위에서 Union-Find 를 구현하기 위해서는 <code class=\"language-text\">트리 구조</code> 를 사용하는 것이 가장 효율적이라고 말했다.</p>\n<p>배열을 사용하는 경우와 트리를 사용하는 경우에 대해서 왜 트리 구조가 더 효율적인지 이해해보자.</p>\n<h3 id=\"배열을-사용해서-구현하기\">배열을 사용해서 구현하기</h3>\n<p>아래의 그림과 같이 각 원소가 집합 번호를 가지는 배열이 있다고 가정해보자.</p>\n<p>다음과 같이 <code class=\"language-text\">초기화</code> 연산을 통해 배열을 만들어준다.</p>\n<div style=\"padding: 0 30%;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/25981283202a019d7d5aa3b897bc0b15/d8f62/image.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 31.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3klEQVR42i2PuQqFMBRE8/+fZGdrIWIhggvuKypxx/UdzEs1mcyZeyOe53nfd13X67oQ53lO0/R+R0qpNJmu63hCE6vrWlHivu99333fH4aBexzHmqYdx4Fv27ZlWZjbthmGAQ9DTNf1eZ7RYhzHtm2ZzJvneUzDyfM8CAJKwZIkaZqGNFtQ3fc9PghCqH3UJYoiWhzHwWFCGIakIUm7rgtPjHbTNCn9w8d3GEgaURQFaT62LAsAWyBw2F+1w+NUVSVYhm6iXMAYSEtZllmW0YsPwObM4SlNU0wQfCnlD1KgT0F1ibOeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image\" title=\"\" src=\"/static/25981283202a019d7d5aa3b897bc0b15/0a47e/image.png\" srcset=\"/static/25981283202a019d7d5aa3b897bc0b15/8a4e8/image.png 150w,\n/static/25981283202a019d7d5aa3b897bc0b15/5a46d/image.png 300w,\n/static/25981283202a019d7d5aa3b897bc0b15/0a47e/image.png 600w,\n/static/25981283202a019d7d5aa3b897bc0b15/d8f62/image.png 601w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</div>\n<br>\n<p>위의 배열에서 다음과 같이 <code class=\"language-text\">Union 연산</code> 을 수행해보았다.</p>\n<ul>\n<li>1번 집합과 2번 집합 합치기\n<ul>\n<li>2번 집합에 있는 2번 원소의 집합을 1번 집합으로 합쳐준다.</li>\n</ul>\n</li>\n<li>2번 집합과 3번 집합 합치기\n<ul>\n<li>3번 집합에 있는 3번 원소를 2번 집합으로 합쳐준다.</li>\n<li>이때 2번 집합은 이전 과정에서 1번 집합으로 합쳐졌기 때문에 1번 집합으로 합쳐져야 한다.</li>\n</ul>\n</li>\n<li>4번 집합과 5번 집합 합치기\n<ul>\n<li>5번 집합에 있는 5번 원소를 4번 집합으로 합쳐준다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6fdc2a7b29adabf006733360cbaab62f/17d12/image2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVR42o2SyW6EMBBE+f8PREignFm8YLAJe/JoK2iUQRrXodWgrqpenE3TZK1VSlmB1pr4k4bMe2+Mgdz3vXMO5jAM27Ylkfd9X9cVf8hN0+CMFjFFIjuOY1mWEKBPELzgW/CZfLVqTG9123bWmjgzinfFKYjJvz8ZhiF4PzoZ2XVdB3+eZ2zpiHhzHpxvSfpkbXmeV1X1JSiKoizLuq7jIdgIBRi0bUsyjuO1MHzw9z5I9MT9D9sL2CsxLpiE0TK5U4e8s4qJSVBNPRW2NIwbySI5/RBnASYxx/CBfL6Ab4ron5srAULx/SDxQA7hKqV5VkLCtbjdmfg8nQAyTB6X1SoMho3cV7ibeif/Aufa9FO4hZzqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image2\"\n        title=\"\"\n        src=\"/static/6fdc2a7b29adabf006733360cbaab62f/0a47e/image2.png\"\n        srcset=\"/static/6fdc2a7b29adabf006733360cbaab62f/8a4e8/image2.png 150w,\n/static/6fdc2a7b29adabf006733360cbaab62f/5a46d/image2.png 300w,\n/static/6fdc2a7b29adabf006733360cbaab62f/0a47e/image2.png 600w,\n/static/6fdc2a7b29adabf006733360cbaab62f/1cfc2/image2.png 900w,\n/static/6fdc2a7b29adabf006733360cbaab62f/c1b63/image2.png 1200w,\n/static/6fdc2a7b29adabf006733360cbaab62f/17d12/image2.png 1666w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><br><br></p>\n<p>위의 그림과 같이 두 집합을 합치기 위해서는 배열의 모든 원소를 찾아서 찾은 집합을 다른 집합 번호로 합쳐주어야 한다.<br>\n따라서, 합칠 때마다 N 번 반복해주어야 하기 때문에 시간복잡도는 <code class=\"language-text\">O(N)</code> 이 된다.</p>\n<p>그럼 특정 원소가 속한 집합을 찾기 위해 <code class=\"language-text\">Find 연산</code> 을 수행한다고 하면 찾고자 하는 원소를 가지는 집합의 인덱스를 통해 찾으면되기 때문에 시간 복잡도는 <code class=\"language-text\">O(1)</code> 이 된다.</p>\n<br>\n<div style=\"padding: 0 30%;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/73beea565ecc98b9ad53336d79699825/d8f62/image3.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 60.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABY0lEQVR42n2SSY+CQBCF+///JqIXTpIg4TLKQVCWQRYVcGHv+aRH4iRm6tApqt+rerxqMY6jlPLxePR9T8J5v9/lFNfrVeVgLpfLDDidToolhmHoum63253PZ0phGC6XSyrc2ba9Xq9Va8Mw4Cimpmm32+1JzrIsSRImcG42m6Io6BLH8X6/L8uS3HXd4/GIiqqqyLlCRZqmnAJO27a0gBYEAb2pMJkKHSGDa5rGcRymwaTLdrtFC3iR5znkuq5pfDgcEAMImu/7/BG0KIqAcssVAJDKC4iCKtfMYQItKTENzSj8nsLzPBQBo06OLnKs4ecFJiEVnf0rVK6MZE7/FhRnDEQh30It4D23LAvNHwFPtz+SxylIWKEij6/4jzwHCufHQ65o89XvI5kHYoOu63jDe2AxJF9TsOTFYoFVOMqbwarVamWa5p/JeAOOExt5AOyPBPMZzjpYDyZR55MubEdK+QP84KrPLd0xeQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image3\" title=\"\" src=\"/static/73beea565ecc98b9ad53336d79699825/0a47e/image3.png\" srcset=\"/static/73beea565ecc98b9ad53336d79699825/8a4e8/image3.png 150w,\n/static/73beea565ecc98b9ad53336d79699825/5a46d/image3.png 300w,\n/static/73beea565ecc98b9ad53336d79699825/0a47e/image3.png 600w,\n/static/73beea565ecc98b9ad53336d79699825/d8f62/image3.png 601w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</div>\n<br>\n<p>이렇게 배열로 Union-Find 를 구현할 수 있지만 Union 연산을 수행할 때 모든 원소를 순회하기 때문에 시간 복잡도는 O(N) 이 된다.<br>\n물론 Find 연산의 시간복잡도는 O(1) 로 빠르지만 트리 구조를 통해 더 빠른 Union 연산을 수행할 수 있다.</p>\n<br>\n<h3 id=\"트리-구조를-사용해서-구현하기\">트리 구조를 사용해서 구현하기</h3>\n<p>배열과 달리 트리 구조를 사용해서 위에서 예를 들었던 Disjoint set 을 아래와 같이 표현할 수 있다.</p>\n<p>따라서, 아래와 같이 트리 구조를 통해 <code class=\"language-text\">초기화</code> 를 진행한다.</p>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/13ba367a8fda948b93d665164555978e/3f8aa/image4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhklEQVR42j2PWQ7EIAxDuf9JEUuhLEVsbZ8azeQD2YmdGOWcm3M+X4UQrusSXGs9z/P5FX2Ugu/7jjG21pS1Vmudc15rgVHw7r0Zg40xsg5qvsKD0nuPTEEYiJpTx3H03scYpEgpyXGisV2mUDAj/AoPUlp4wKQFs0vU8iNoKeVPyYKz1voCnU3l8PFcdNkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image4\"\n        title=\"\"\n        src=\"/static/13ba367a8fda948b93d665164555978e/0a47e/image4.png\"\n        srcset=\"/static/13ba367a8fda948b93d665164555978e/8a4e8/image4.png 150w,\n/static/13ba367a8fda948b93d665164555978e/5a46d/image4.png 300w,\n/static/13ba367a8fda948b93d665164555978e/0a47e/image4.png 600w,\n/static/13ba367a8fda948b93d665164555978e/1cfc2/image4.png 900w,\n/static/13ba367a8fda948b93d665164555978e/c1b63/image4.png 1200w,\n/static/13ba367a8fda948b93d665164555978e/3f8aa/image4.png 1337w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><br><br></p>\n<p>트리 구조를 통해 연산을 수행하기 위해서 기본적으로 알아야 하는 내용이 있다.</p>\n<ol>\n<li>한 집합에 속하는 원소들을 하나의 트리로 묶어준다.</li>\n<li>트리 구조에는 루트 노드가 존재한다. 루트 노드가 집합의 번호가 된다.</li>\n<li>Union 연산을 수행하기 위해서는 두 원소가 같은 집합에 속하는지 먼저 확인한 후 다른 집합에 속할때만 합쳐야 한다.</li>\n<li>Find 연산을 수행하기 위해서는 모든 자식 노드가 부모에 대한 포인터 정보를 가지고 있도록 한다. 결과적으로 최종 부모인 루트 노드가 무엇인지 찾을 수 있게 된다. 여기서 부모 노드는 자식 노드에 대한 정보를 가질 필요는 없다.</li>\n</ol>\n<p>이와 같은 점들을 유의해서 Union 연산과 Find 연산을 해보도록 하자.</p>\n<p>먼저, <code class=\"language-text\">Union 연산</code> 을 수행해보자. Union 연산의 수행은 배열에서 진행했던 과정 그대로 진행하려고 한다.</p>\n<ul>\n<li>1번 집합과 2번 집합 합치기\n<ul>\n<li>2번 집합의 루트 노드를 1번 집합의 자식 노드로 만들어준다.</li>\n</ul>\n</li>\n<li>2번 집합과 3번 집합 합치기\n<ul>\n<li>3번 집합의 루트 노드를 2번 집합의 자식 노드로 만들어준다.</li>\n<li>이때, 2번 집합의 루트 노드는 1번 집합이므로 3번 집합의 루트 노드는 1번 집합이 된다.</li>\n</ul>\n</li>\n<li>4번 집합과 5번 집합 합치기\n<ul>\n<li>5번 집합의 루트 노드를 4번 집합의 자식 노드로 만들어준다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1af5f85135286c2ee6c748615d71df58/76435/image5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 154.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAIAAABoLHqZAAAACXBIWXMAAAsTAAALEwEAmpwYAAACCElEQVR42pWU67KCMAyEff9XdBzvOiPiDQUttD0fXQ8qIGB+OGvTbbbZlNH1ej2dTt77NE0vl4tzjhUAK0VRHI/HIkQcx8YY/xkjmCREiKIoSZLD4QBga5ZlpM7nM+fu93sOqpNJ3O93zn6EoDIrAHLwwdbaCtTJ2sTxVFuv18vlcrVabbdbwGazAex2uzzP2ca5LWRyHIzI2+3GKfzqFlwBLGZrlORzCABbIVABhdwQGkB3bpYtyWopjaEyAJFcmFNoGzQwrSL7tTL6jCm1wVerqKnmESw2W1WRXZHGLk+buUpqq+ZAdtankTdJa7pGk5YP2d6jyuV5gTzUYjvmARAM1hUA7VZpVfbMZrP5fI7V+AyeTCaLxWI6nY7HY2aRDfsQ8m9UHUM1KksYFuhQgPsPG4IVbXuRWcIbtZoc3qATgO0o+t6wEBiLKo0KNA7Cc7QIdFj11AxfmPvIW+RQtmc8NR5Ubhrr3qL59yUbzR1FumXnKKzlTIgkBFk9m1sIPOO1PMnWpEVW/1CQplt65LjN25b/BI+fm5azXW58JC47ePsh+70LXbLLCbfmfSu4+uL1NCzMia3IGqOhDWMrIqth0rell//ymd26JIbRJ/BQMhxs0HvQt6XC/WRV08Mo3/Y1ciYdSoaGTsQHbuHvJ59nQ8ma0Ncl4Xc6XH9Vb7J/nu1yhn8l/wF7TR4P7xGitwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image5\"\n        title=\"\"\n        src=\"/static/1af5f85135286c2ee6c748615d71df58/0a47e/image5.png\"\n        srcset=\"/static/1af5f85135286c2ee6c748615d71df58/8a4e8/image5.png 150w,\n/static/1af5f85135286c2ee6c748615d71df58/5a46d/image5.png 300w,\n/static/1af5f85135286c2ee6c748615d71df58/0a47e/image5.png 600w,\n/static/1af5f85135286c2ee6c748615d71df58/1cfc2/image5.png 900w,\n/static/1af5f85135286c2ee6c748615d71df58/c1b63/image5.png 1200w,\n/static/1af5f85135286c2ee6c748615d71df58/76435/image5.png 1742w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><br><br></p>\n<p>이렇게 트리 구조를 통해 Union 연산을 수행할 때 집합의 모든 원소를 다 찾을 필요없이 합치려고 하는 루트 노드를 찾아 합쳐주면된다.<br>\n따라서, 시간 복잡도는 <code class=\"language-text\">O(N) 보다 작아</code> 지게 되고 Union 하는 과정에서 Find 연산을 통해 루트 노드를 찾기 때문에 Find 연산에 따라 시간복잡도가 달라지게 된다.</p>\n<p>이렇게 Union 연산을 합쳐진 트리 구조에서 <code class=\"language-text\">Find 연산</code> 을 하려면 찾는 원소의 포인터를 따라가 루트 노드를 찾으면 된다.<br>\n이때, 시간복잡도는 <code class=\"language-text\">트리의 높이에 따라 비례</code> 하는 것을 알 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/762e78e6131f90fad7e5650faa79bb74/9c2cf/image6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0klEQVR42m2R2w6DIBBE+f+/NGpT74oi3qA9YY2xlXnY7JIZdgbUJwbv/XEcbdtO00TPyTzPVVVt2yajQD2V+76v62qt1VrXdc3IYd/3XddR70zlA2SbNMaYcRyh0rBKeFyEC+fcj/i5GSVroQ7DcLFtwB9TQSUMfnBYFAXbkBFYxEQVU4wQLiOnmEhcuSwLOamMCGhgY1XYiOUJxMgVMGIbJXoc3W1HERezEP98FQ01SZJ3QJqmWZZRSUq0+FdJEB6cLE3TvALKsqTyLnmeU7XWX+rCDMuvPvR0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image6\"\n        title=\"\"\n        src=\"/static/762e78e6131f90fad7e5650faa79bb74/0a47e/image6.png\"\n        srcset=\"/static/762e78e6131f90fad7e5650faa79bb74/8a4e8/image6.png 150w,\n/static/762e78e6131f90fad7e5650faa79bb74/5a46d/image6.png 300w,\n/static/762e78e6131f90fad7e5650faa79bb74/0a47e/image6.png 600w,\n/static/762e78e6131f90fad7e5650faa79bb74/1cfc2/image6.png 900w,\n/static/762e78e6131f90fad7e5650faa79bb74/c1b63/image6.png 1200w,\n/static/762e78e6131f90fad7e5650faa79bb74/9c2cf/image6.png 1557w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br>\n<h3 id=\"배열과-트리-비교\">배열과 트리 비교</h3>\n<ul>\n<li>\n<p><strong>Union 연산 시간복잡도 비교</strong></p>\n<ul>\n<li>배열의 경우 원소만큼 N번 합쳐주어야 하기 해야하기 때문에 시간복잡도는 O(N) 이 된다.</li>\n<li>트리의 경우 루트 노드를 다른 집합의 자식 노드로 합쳐주면 되기 때문에 시간복잡도는 O(N) 보다 작게 된다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Find 연산 시간복잡도 비교</strong></p>\n<ul>\n<li>배열의 경우 특정 원소의 집합을 찾으면 바로 집합을 찾을 수 있기 때문에 시간복잡도는 O(1) 이 된다.</li>\n<li>트리의 경우 특정 원소의 집합을 찾으려면 원소가 포함된 트리의 루트 노드를 찾아야 하기 때문에 시간복잡도는 트리의 높이에 비례한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"union-find-최적화\">Union-find 최적화</h2>\n<p>위와 같이 Union-Find 알고리즘을 통해 연산을 수행해봤는데 트리 구조를 사용하는 경우에 큰 문제가 발생할 수 있다.</p>\n<p>최악의 경우 완전 비대칭 트리가 되어 버리면 N 개의 노드가 있을 경우 트리의 높이가 N-1 인 연결 리스트와 같은 트리 구조가 되어 Find 연산의 시간복잡도가 O(N) 이 되어 버린다.<br>\n그래서 최악의 경우 트리 구조를 사용했을 경우 배열보다 비효율적이게 된다.</p>\n<div style=\"padding: 0 20%;\">\n    <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2f1ab34cdc466606a350441405320600/99072/image7.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 151.99999999999997%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAeCAIAAACjcKk8AAAACXBIWXMAAAsTAAALEwEAmpwYAAABmklEQVR42pWVyY7CQAxE+///j1MEESKQlezLDFmYp7ZkIs0hxoeWp6fLZZft4N4227btfD4HQXDzdr/fsyxzb7NN0/Tj7dcbjrMzc87zDGHXdXLp7Ejs9XrFcZym6RdgMH3fE+L5fLZtC7mEcxbOqqoAk3Nd1xJoGAYrc57n67ouywInyKIoEMwE5l1Zlip4FEXgj2uWnJumGcdRbiCn7M2bCUyS1Ck3pA0zNybBBIxUOEwF+ZMz+pkEo2DA6tNhTgr5CKYz8H8qYENqvYH28XjQatOQABZmFQlylcAR+Hq9hmGYJMnlckEP/n06ncDI6kifFMz7D5jsmRvZGFrCiU9VvMAnT3qzbxvRpRCTYAKWCcFnpchFyj4QbD9e+DSJdEDK2DjjbEo4MKykhjsGw7YXTGfmGIxsyKnMnGjGhlnBvN4vNv2zpg0GeXS8AKM5YE7TVtEbNlEXg4JNHwMFi0L8KWqbvp4KhnNftlVtGSzdSqLwc6EzdwymMaQKLQ57gn6Nty8+vbwmW1ai9Sbkpk8vaou8lTf4Re0/LYfjgwJ9EeMAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"image7\" title=\"\" src=\"/static/2f1ab34cdc466606a350441405320600/0a47e/image7.png\" srcset=\"/static/2f1ab34cdc466606a350441405320600/8a4e8/image7.png 150w,\n/static/2f1ab34cdc466606a350441405320600/5a46d/image7.png 300w,\n/static/2f1ab34cdc466606a350441405320600/0a47e/image7.png 600w,\n/static/2f1ab34cdc466606a350441405320600/99072/image7.png 842w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</div>\n<p><br><br></p>\n<p>따라서 이와 같은 문제가 발생하면 다음과 같이 <strong>두 가지 최적화 방법</strong>을 통해 방지할 수 있다.</p>\n<h3 id=\"union-연산-최적화\">Union 연산 최적화</h3>\n<p>Union 연산을 최적화 하는 방법으로 <code class=\"language-text\">union-by-rank</code> 가 있다.<br>\nUnion 연산을 수행하는 과정에서 <strong><U>항상 높이가 더 낮은 트리를 높은 트리 밑에 넣어준다.</U></strong></p>\n<p>쉽게 말해서 자식 노드가 추가되면 루트 노드의 rank 가 증가하게 되고 rank 가 작은 노드가 rank 가 큰 노드의 자식 노드가 된다.<br>\n이와 같은 방법으로 트리의 높이가 높아지는 현상을 방지할 수 있다고 한다.</p>\n<p>두 트리의 크기를 비교하기 위해 rank 를 사용하게 되는데 여기서 주의해야할 점은 rank 가 height 이 아니라는 점이다.</p>\n<br>\n<h3 id=\"find-연산-최적화\">Find 연산 최적화</h3>\n<p>Find 연산을 최적화 하는 방법으로 <code class=\"language-text\">경로 압축 (Path Compression)</code> 이 있다.<br>\nFind 연산을 수행할 때 포인터를 통해 루트 노드를 찾는 과정에서 트리의 높이에 비례해서 연산을 수행하게 된다.<br>\n이러한 과정에서 루트 노드를 찾고자 하는 집합 노드의 루트 노드로 만들어 찾는 과정에서 중간 노드를 생략하는 방법이라고 할 수 있다.<br>\n따라서 중간 노드가 생략되어 버리기 때문에 경로가 압축되었다고 할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9ed652914860f6db10a4bad4b06b579a/b88bf/image8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAArklEQVR42o2QSRKEIAxFuf9RLRFERhnsJ1k2Vd1Z6If8IUGFEM7zrLXe922MyTk/q4JgrRXcWkMFUCj3fQ+ztm3z3i/FMcbjOEQPE+ycUyklSSNZ/JaFjLlKKWDyUDKL4icaXGCMMZjqmkWLS1q4MxFKLjkCJE/hBwlEm2HEGzuttWDsiJIWe/GFyaZvMgdJ7r2TuZw5z6LL5nixIAC+YpLlI0F6ftX72tQ/1G/xBxFo1LUesdsiAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image8\"\n        title=\"\"\n        src=\"/static/9ed652914860f6db10a4bad4b06b579a/0a47e/image8.png\"\n        srcset=\"/static/9ed652914860f6db10a4bad4b06b579a/8a4e8/image8.png 150w,\n/static/9ed652914860f6db10a4bad4b06b579a/5a46d/image8.png 300w,\n/static/9ed652914860f6db10a4bad4b06b579a/0a47e/image8.png 600w,\n/static/9ed652914860f6db10a4bad4b06b579a/1cfc2/image8.png 900w,\n/static/9ed652914860f6db10a4bad4b06b579a/c1b63/image8.png 1200w,\n/static/9ed652914860f6db10a4bad4b06b579a/b88bf/image8.png 1702w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<br>\n<p>위의 이미지와 같이 경로를 압축해 2번 집합이나 3번 집합 둘 다 1번 집합을 루트 노드로 되어있기 때문에 3번 집합의 경우 2번 집합을 거치지 않아도 된다는 점을 통해 루트 노드를 찾는 경로를 압축시켜버렸다.\n그 결과 트리의 높이가 2 에서 1 로 낮아지게 되어 더 빠르게 찾을 수 있다.</p>\n<br>\n<p>결과적으로 두 가지의 최적화 방법을 사용하면 트리 구조의 Union-Find 알고리즘의 시간복잡도를 <code class=\"language-text\">O(h)</code> 에서 <code class=\"language-text\">O(logN)</code> 으로 줄일 수 있다고 한다.</p>\n<br>\n<h2 id=\"union-find-알고리즘-관련-문제\">Union-Find 알고리즘 관련 문제</h2>\n<ul>\n<li><a href=\"https://www.acmicpc.net/problem/1043\">백준 온라인 저지 1043번</a></li>\n<li><a href=\"https://www.acmicpc.net/workbook/view/900\">백준 Union-Find 공개 문제집</a></li>\n<li><a href=\"https://leetcode.com/tag/union-find/\">Leetcode Union Find 문제 모음</a></li>\n</ul>\n<br>\n<h2 id=\"참고-레퍼런스\">참고 레퍼런스</h2>\n<p><a href=\"https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html\">https://gmlwjd9405.github.io/2018/08/31/algorithm-union-find.html</a><br>\n<a href=\"https://yoongrammer.tistory.com/102\">https://yoongrammer.tistory.com/102</a><br>\n<a href=\"http://bowbowbow.tistory.com/26\">http://bowbowbow.tistory.com/26</a></p>","frontmatter":{"title":"Union-Find 알고리즘 이해하기","date":"2024년 07월 17일","description":"Union-Find 알고리즘에 대해서 공부하고 정리한 내용입니다.","tags":["algorithm","union-find","disjoint-set","union","find"],"categories":"algorithm/concept"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#union-find-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\">Union-Find 알고리즘이란</a></p>\n<ul>\n<li><a href=\"#disjoint-set-%EC%9D%B4%EB%9E%80\">Disjoint set 이란</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#union-find-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0\">Union-Find 알고리즘 이해하기</a></p>\n<ul>\n<li><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">배열을 사용해서 구현하기</a></li>\n<li><a href=\"#%ED%8A%B8%EB%A6%AC-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">트리 구조를 사용해서 구현하기</a></li>\n<li><a href=\"#%EB%B0%B0%EC%97%B4%EA%B3%BC-%ED%8A%B8%EB%A6%AC-%EB%B9%84%EA%B5%90\">배열과 트리 비교</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#union-find-%EC%B5%9C%EC%A0%81%ED%99%94\">Union-find 최적화</a></p>\n<ul>\n<li><a href=\"#union-%EC%97%B0%EC%82%B0-%EC%B5%9C%EC%A0%81%ED%99%94\">Union 연산 최적화</a></li>\n<li><a href=\"#find-%EC%97%B0%EC%82%B0-%EC%B5%9C%EC%A0%81%ED%99%94\">Find 연산 최적화</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#union-find-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B4%80%EB%A0%A8-%EB%AC%B8%EC%A0%9C\">Union-Find 알고리즘 관련 문제</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\">참고 레퍼런스</a></p>\n</li>\n</ul>","timeToRead":4}},"pageContext":{"slug":"/algorithm/concept/what-is-union-find/","previous":{"fields":{"slug":"/algorithm/concept/what-is-monotonic-stack/"},"frontmatter":{"title":"Monotonic Stack (단조 스택) 알고리즘 이해하기","categories":"algorithm/concept"}},"next":null}},"staticQueryHashes":["1128308798","2390591302","4172325373"],"slicesMap":{}}